!function(Q){var F={};function B(I){if(F[I])return F[I].exports;var U=F[I]={i:I,l:!1,exports:{}};return Q[I].call(U.exports,U,U.exports,B),U.l=!0,U.exports}B.m=Q,B.c=F,B.d=function(Q,F,I){B.o(Q,F)||Object.defineProperty(Q,F,{enumerable:!0,get:I})},B.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},B.t=function(Q,F){if(1&F&&(Q=B(Q)),8&F)return Q;if(4&F&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var I=Object.create(null);if(B.r(I),Object.defineProperty(I,"default",{enumerable:!0,value:Q}),2&F&&"string"!=typeof Q)for(var U in Q)B.d(I,U,function(F){return Q[F]}.bind(null,U));return I},B.n=function(Q){var F=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return B.d(F,"a",F),F},B.o=function(Q,F){return Object.prototype.hasOwnProperty.call(Q,F)},B.p="",B(B.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/js/util.js\n/**\n * Generic debounce utility\n * \n * @param {Function} fn \n * @param {Int} timeout \n */\nfunction debounce(fn, timeout) {\n  var timerInterval = timeout;\n  var timer;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (!timer) {\n      clearTimeout(timer);\n    }\n\n    timer = setTimeout(function () {\n      fn.apply(null, args);\n    }, timerInterval);\n  };\n}\n\n/* harmony default export */ var util = ({\n  debounce: debounce\n});\n// CONCATENATED MODULE: ./src/js/autocomplete.js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Autocomplete =\n/*#__PURE__*/\nfunction () {\n  function Autocomplete(selector, options) {\n    _classCallCheck(this, Autocomplete);\n\n    this.eleselector = selector;\n    this.options = $.extend({}, options, {});\n    this.containerSelector = this.eleselector + '-container';\n    this.items = options.items || [];\n\n    _initialize();\n  }\n  /**\n   * Initializes the DOM for the autocomplete. Does thhis\n   * eagerly instead of on-demand/on the fly.\n   */\n\n\n  _createClass(Autocomplete, [{\n    key: \"_initialize\",\n    value: function _initialize() {\n      if ($(this.containerSelector).length == 0) {\n        $('body').append('<div id=\"' + this.containerSelector + '\"></div>');\n      }\n\n      _attachEvents();\n    }\n    /**\n     * handles only the click/select event. However we can\n     * handle keyboard naviagtion to move up/down.\n     */\n\n  }, {\n    key: \"_attachEvents\",\n    value: function _attachEvents() {\n      $(this.containerSelector).on('click', 'a', function () {\n        var targetEle = event.target;\n        var selectedValue = targetEle.dataset.name;\n        this.options.select && this.options.select($(this.eleselector), selectedValue);\n      });\n    }\n  }, {\n    key: \"open\",\n\n    /**\n     *  Opens the autocomplete list\n     */\n    value: function open() {\n      $(this.containerSelector).show();\n    }\n    /**\n     * Close the autocomplete list.\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      $(this.containerSelector).hide();\n    }\n  }, {\n    key: \"setItems\",\n    value: function setItems(items) {\n      this.items = items;\n      this.generateList();\n    }\n  }, {\n    key: \"generateList\",\n    value: function generateList() {\n      var html = \"<ul><li>\" + this.items.map(function (item) {\n        return \"<a href='' data-name='\" + item + \"'>\" + item + \"</a>\";\n      }).reduce(function (a, b) {\n        return a + \"</li><li>\" + b;\n      }) + \"</li><ul>\";\n      this.containerSelector.html(html);\n    }\n  }, {\n    key: \"render\",\n    value: function render(items) {\n      this.setItems(items);\n      this.open();\n    }\n  }], [{\n    key: \"defaultSelector\",\n\n    /**\n     * Default selector function which sets the\n     * value\n     * \n     * @param {*} ele \n     * @param {*} value \n     */\n    value: function defaultSelector(ele, value) {\n      $(ele).value(value);\n    }\n  }]);\n\n  return Autocomplete;\n}();\n\n\n// CONCATENATED MODULE: ./src/js/Suggestion.js\n/**\n * @param word to get the suggestion from\n * @returns Promise \n */\nvar lastWord, lastWordPromise;\n\nfunction wordSuggestions(word) {\n  var defer = $.Deferred();\n  var matches = ['_pre_$', '_pre_$_post', '$_post'];\n  var to_return = {\n    word: word,\n    matches: matches.map(function (a) {\n      return a.replace('$', word);\n    }) + [word]\n  }; //random timeout\n\n  setTimeout(function () {\n    defer.resolve(to_return);\n  }, Math.floor(Math.random * 1000));\n  return defer.promise();\n}\n/**\n * hanldes the out of order suggestions properly.\n */\n\n\nfunction getSuggestions(word) {\n  if (lastWordPromise) {\n    getWords(word);\n    return lastWordPromise;\n  }\n\n  defer = new $.Deferred();\n  lastWordPromise = defer.promise();\n  lastWord = word;\n\n  function getWords(wrd) {\n    wordSuggestions(wrd).done(function (res) {\n      if (res && res.word == lastWord) {\n        defer.resolve(res.matches);\n      }\n\n      lastWordPromise = null;\n      lastWord = null;\n    });\n  }\n\n  getWords();\n  return lastWordPromise;\n}\n\n/* harmony default export */ var Suggestion = ({\n  getSuggestions: getSuggestions\n});\n// CONCATENATED MODULE: ./src/js/app.js\n/**\n * Initializer\n */\n\n\n\n\nwindow.onload = function () {\n  var autoComplete = new Autocomplete('#searchBox', {\n    select: autoCompletSelector\n  }); // debounce it for 100ms\n\n  $('#searchBox').on('keyup', util(function (event, ui) {\n    var selStart = event.target.selectionStart;\n    var selEnd = event.target.selectionEnd;\n    var value = $(this).val();\n    var wordToGetSuggestion;\n\n    if (selStart == selEnd && selEnd == value.length) {\n      //cursor is at the last position\n      //get the last word.\n      wordToGetSuggestion = value.split(' ').pop();\n    } else {\n      //if selection has multiple words, then we get the\n      //first word\n      wordToGetSuggestion = value.substr(selStart).split(' ').pop(0);\n    }\n\n    var matches = Suggestion(wordToGetSuggestion);\n    autoComplete.renderItems(matches);\n  }, 100));\n\n  var autoCompletSelector = function autoCompletSelector(ele, selectedItem) {\n    var existingValue = ele.val();\n    var values = existingValue.split(' ');\n    var selectedValue = selectedItem; // store the last cursor position, \n\n    var cursorPosition = ele.data('cursor');\n\n    if (cursorPosition == existingValue.length) {\n      values.pop();\n      values.push(selectedItem);\n      to_set = values.join(' ');\n    }\n\n    var before = existingValue.substr(0, cursorPosition).lastIndexOf(' ');\n    var after = existingValue.substr(cursorPosition).indexOf(' ');\n\n    if (before != -1) {\n      to_set = existingValue.substr(0, before) + ' ';\n    }\n\n    to_set = selectedItem;\n\n    if (after != -1) {\n      to_set = existingValue.substr(0, after);\n    }\n\n    ele.value(to_set); // after selecting it close it.\n\n    autoComplete.close();\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbC5qcz9mNjQ0Iiwid2VicGFjazovLy8uL3NyYy9qcy9hdXRvY29tcGxldGUuanM/NjQ3YiIsIndlYnBhY2s6Ly8vLi9zcmMvanMvU3VnZ2VzdGlvbi5qcz8zNDZhIiwid2VicGFjazovLy8uL3NyYy9qcy9hcHAuanM/OTBlOSJdLCJuYW1lcyI6WyJkZWJvdW5jZSIsImZuIiwidGltZW91dCIsInRpbWVySW50ZXJ2YWwiLCJ0aW1lciIsImFyZ3MiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiYXBwbHkiLCJBdXRvY29tcGxldGUiLCJzZWxlY3RvciIsIm9wdGlvbnMiLCJlbGVzZWxlY3RvciIsIiQiLCJleHRlbmQiLCJjb250YWluZXJTZWxlY3RvciIsIml0ZW1zIiwiX2luaXRpYWxpemUiLCJsZW5ndGgiLCJhcHBlbmQiLCJfYXR0YWNoRXZlbnRzIiwib24iLCJ0YXJnZXRFbGUiLCJldmVudCIsInRhcmdldCIsInNlbGVjdGVkVmFsdWUiLCJkYXRhc2V0IiwibmFtZSIsInNlbGVjdCIsInNob3ciLCJoaWRlIiwiZ2VuZXJhdGVMaXN0IiwiaHRtbCIsIm1hcCIsIml0ZW0iLCJyZWR1Y2UiLCJhIiwiYiIsInNldEl0ZW1zIiwib3BlbiIsImVsZSIsInZhbHVlIiwibGFzdFdvcmQiLCJsYXN0V29yZFByb21pc2UiLCJ3b3JkU3VnZ2VzdGlvbnMiLCJ3b3JkIiwiZGVmZXIiLCJEZWZlcnJlZCIsIm1hdGNoZXMiLCJ0b19yZXR1cm4iLCJyZXBsYWNlIiwicmVzb2x2ZSIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInByb21pc2UiLCJnZXRTdWdnZXN0aW9ucyIsImdldFdvcmRzIiwid3JkIiwiZG9uZSIsInJlcyIsIndpbmRvdyIsIm9ubG9hZCIsImF1dG9Db21wbGV0ZSIsImF1dG9Db21wbGV0U2VsZWN0b3IiLCJ1aSIsInNlbFN0YXJ0Iiwic2VsZWN0aW9uU3RhcnQiLCJzZWxFbmQiLCJzZWxlY3Rpb25FbmQiLCJ2YWwiLCJ3b3JkVG9HZXRTdWdnZXN0aW9uIiwic3BsaXQiLCJwb3AiLCJzdWJzdHIiLCJyZW5kZXJJdGVtcyIsInNlbGVjdGVkSXRlbSIsImV4aXN0aW5nVmFsdWUiLCJ2YWx1ZXMiLCJjdXJzb3JQb3NpdGlvbiIsImRhdGEiLCJwdXNoIiwidG9fc2V0Iiwiam9pbiIsImJlZm9yZSIsImxhc3RJbmRleE9mIiwiYWZ0ZXIiLCJpbmRleE9mIiwiY2xvc2UiXSwibWFwcGluZ3MiOiI7OztBQUFBOzs7Ozs7QUFNQSxTQUFTQSxRQUFULENBQWtCQyxFQUFsQixFQUFzQkMsT0FBdEIsRUFBOEI7QUFDMUIsTUFBTUMsYUFBYSxHQUFHRCxPQUF0QjtBQUNBLE1BQUlFLEtBQUo7QUFFQSxTQUFPLFlBQWlCO0FBQUEsc0NBQUxDLElBQUs7QUFBTEEsVUFBSztBQUFBOztBQUNwQixRQUFHLENBQUNELEtBQUosRUFBVTtBQUNORSxrQkFBWSxDQUFDRixLQUFELENBQVo7QUFDSDs7QUFDREEsU0FBSyxHQUFHRyxVQUFVLENBQUMsWUFBVTtBQUN6Qk4sUUFBRSxDQUFDTyxLQUFILENBQVMsSUFBVCxFQUFlSCxJQUFmO0FBQ0gsS0FGaUIsRUFFZkYsYUFGZSxDQUFsQjtBQUdILEdBUEQ7QUFRSDs7QUFFYztBQUNYSCxVQUFRLEVBQVJBO0FBRFcsQ0FBZixFOzs7Ozs7OztJQ3BCcUJTLFk7OztBQUVqQix3QkFBWUMsUUFBWixFQUFzQkMsT0FBdEIsRUFBOEI7QUFBQTs7QUFDMUIsU0FBS0MsV0FBTCxHQUFtQkYsUUFBbkI7QUFDQSxTQUFLQyxPQUFMLEdBQWVFLENBQUMsQ0FBQ0MsTUFBRixDQUFTLEVBQVQsRUFBYUgsT0FBYixFQUFzQixFQUF0QixDQUFmO0FBQ0EsU0FBS0ksaUJBQUwsR0FBeUIsS0FBS0gsV0FBTCxHQUFtQixZQUE1QztBQUNBLFNBQUtJLEtBQUwsR0FBYUwsT0FBTyxDQUFDSyxLQUFSLElBQWlCLEVBQTlCOztBQUVBQyxlQUFXO0FBQ2Q7QUFFRDs7Ozs7Ozs7a0NBSWE7QUFDVCxVQUFJSixDQUFD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QW1ELEdBQW5ELENBQWI7QUFDQSxRQUFJQyxLQUFLLEdBQUdULGFBQWEsQ0FBQ0gsTUFBZCxDQUFxQkssY0FBckIsRUFBcUNRLE9BQXJDLENBQTZDLEdBQTdDLENBQVo7O0FBQ0EsUUFBR0gsTUFBTSxJQUFJLENBQUMsQ0FBZCxFQUFnQjtBQUNaRixZQUFNLEdBQUdMLGFBQWEsQ0FBQ0gsTUFBZCxDQUFxQixDQUFyQixFQUF3QlUsTUFBeEIsSUFBa0MsR0FBM0M7QUFDSDs7QUFDREYsVUFBTSxHQUFHTixZQUFUOztBQUNBLFFBQUdVLEtBQUssSUFBSSxDQUFDLENBQWIsRUFBZTtBQUNYSixZQUFNLEdBQUdMLGFBQWEsQ0FBQ0gsTUFBZCxDQUFxQixDQUFyQixFQUF3QlksS0FBeEIsQ0FBVDtBQUNIOztBQUVEOUMsT0FBRyxDQUFDQyxLQUFKLENBQVV5QyxNQUFWLEVBdkJpRCxDQXdCakQ7O0FBQ0FuQixnQkFBWSxDQUFDeUIsS0FBYjtBQUNILEdBMUJEO0FBMkJILENBdEREIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdlbmVyaWMgZGVib3VuY2UgdXRpbGl0eVxuICogXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBcbiAqIEBwYXJhbSB7SW50fSB0aW1lb3V0IFxuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmbiwgdGltZW91dCl7XG4gICAgY29uc3QgdGltZXJJbnRlcnZhbCA9IHRpbWVvdXQ7XG4gICAgbGV0IHRpbWVyO1xuICAgIFxuICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKXtcbiAgICAgICAgaWYoIXRpbWVyKXtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTsgICAgIFxuICAgICAgICB9LCB0aW1lckludGVydmFsKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGRlYm91bmNlXG59IiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXV0b2NvbXBsZXRlIHtcbiAgIFxuICAgIGNvbnN0cnVjdG9yKHNlbGVjdG9yLCBvcHRpb25zKXtcbiAgICAgICAgdGhpcy5lbGVzZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgb3B0aW9ucywge30pXG4gICAgICAgIHRoaXMuY29udGFpbmVyU2VsZWN0b3IgPSB0aGlzLmVsZXNlbGVjdG9yICsgJy1jb250YWluZXInO1xuICAgICAgICB0aGlzLml0ZW1zID0gb3B0aW9ucy5pdGVtcyB8fCBbXTtcblxuICAgICAgICBfaW5pdGlhbGl6ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBET00gZm9yIHRoZSBhdXRvY29tcGxldGUuIERvZXMgdGhoaXNcbiAgICAgKiBlYWdlcmx5IGluc3RlYWQgb2Ygb24tZGVtYW5kL29uIHRoZSBmbHkuXG4gICAgICovXG4gICAgX2luaXRpYWxpemUoKXtcbiAgICAgICAgaWYgKCQodGhpcy5jb250YWluZXJTZWxlY3RvcikubGVuZ3RoID09IDApe1xuICAgICAgICAgICAgJCgnYm9keScpLmFwcGVuZCgnPGRpdiBpZD1cIicgKyB0aGlzLmNvbnRhaW5lclNlbGVjdG9yICsgJ1wiPjwvZGl2PicpXG4gICAgICAgIH1cblxuICAgICAgICBfYXR0YWNoRXZlbnRzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGFuZGxlcyBvbmx5IHRoZSBjbGljay9zZWxlY3QgZXZlbnQuIEhvd2V2ZXIgd2UgY2FuXG4gICAgICogaGFuZGxlIGtleWJvYXJkIG5hdmlhZ3Rpb24gdG8gbW92ZSB1cC9kb3duLlxuICAgICAqL1xuICAgIF9hdHRhY2hFdmVudHMoKXtcbiAgICAgICAgJCh0aGlzLmNvbnRhaW5lclNlbGVjdG9yKS5vbignY2xpY2snLCAnYScsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0RWxlID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkVmFsdWUgPSB0YXJnZXRFbGUuZGF0YXNldC5uYW1lO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNlbGVjdCAmJiB0aGlzLm9wdGlvbnMuc2VsZWN0KCQodGhpcy5lbGVzZWxlY3RvciksIHNlbGVjdGVkVmFsdWUpXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHNlbGVjdG9yIGZ1bmN0aW9uIHdoaWNoIHNldHMgdGhlXG4gICAgICogdmFsdWVcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0geyp9IGVsZSBcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFxuICAgICAqL1xuICAgIHN0YXRpYyBkZWZhdWx0U2VsZWN0b3IoZWxlLCB2YWx1ZSl7XG4gICAgICAgICQoZWxlKS52YWx1ZSh2YWx1ZSlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgT3BlbnMgdGhlIGF1dG9jb21wbGV0ZSBsaXN0XG4gICAgICovXG4gICAgb3Blbigpe1xuICAgICAgICAkKHRoaXMuY29udGFpbmVyU2VsZWN0b3IpLnNob3coKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgYXV0b2NvbXBsZXRlIGxpc3QuXG4gICAgICovXG4gICAgY2xvc2UoKXtcbiAgICAgICAgJCh0aGlzLmNvbnRhaW5lclNlbGVjdG9yKS5oaWRlKCk7XG4gICAgfVxuXG4gICAgc2V0SXRlbXMoaXRlbXMpe1xuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVMaXN0KCk7XG4gICAgfVxuXG4gICAgZ2VuZXJhdGVMaXN0KCl7XG4gICAgICAgIHZhciBodG1sID0gXCI8dWw+PGxpPlwiICsgdGhpcy5pdGVtcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiPGEgaHJlZj0nJyBkYXRhLW5hbWU9J1wiICsgaXRlbSArIFwiJz5cIiArIGl0ZW0gKyBcIjwvYT5cIlxuICAgICAgICB9KS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBcIjwvbGk+PGxpPlwiICsgYikgKyBcIjwvbGk+PHVsPlwiXG5cbiAgICAgICAgdGhpcy5jb250YWluZXJTZWxlY3Rvci5odG1sKGh0bWwpXG4gICAgfVxuXG4gICAgcmVuZGVyKGl0ZW1zKXtcbiAgICAgICAgdGhpcy5zZXRJdGVtcyhpdGVtcyk7XG4gICAgICAgIHRoaXMub3BlbigpO1xuICAgIH1cbn1cbiIsIi8qKlxuICogQHBhcmFtIHdvcmQgdG8gZ2V0IHRoZSBzdWdnZXN0aW9uIGZyb21cbiAqIEByZXR1cm5zIFByb21pc2UgXG4gKi9cbnZhciBsYXN0V29yZCwgbGFzdFdvcmRQcm9taXNlO1xuXG5mdW5jdGlvbiB3b3JkU3VnZ2VzdGlvbnMod29yZCl7ICBcbiAgICB2YXIgZGVmZXIgPSAkLkRlZmVycmVkKCk7XG4gICAgdmFyIG1hdGNoZXMgPSBbJ19wcmVfJCcsICdfcHJlXyRfcG9zdCcsICckX3Bvc3QnXTtcbiAgICB2YXIgdG9fcmV0dXJuID0ge1xuICAgICAgICB3b3JkOiB3b3JkLFxuICAgICAgICBtYXRjaGVzOiBtYXRjaGVzLm1hcChhID0+IGEucmVwbGFjZSgnJCcsIHdvcmQpKSArIFt3b3JkXVxuICAgIH1cblxuICAgIC8vcmFuZG9tIHRpbWVvdXRcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgIGRlZmVyLnJlc29sdmUodG9fcmV0dXJuKVxuICAgIH0sIE1hdGguZmxvb3IoTWF0aC5yYW5kb20gKiAxMDAwKSk7XG5cbiAgICByZXR1cm4gZGVmZXIucHJvbWlzZSgpO1xufVxuXG5cbi8qKlxuICogaGFubGRlcyB0aGUgb3V0IG9mIG9yZGVyIHN1Z2dlc3Rpb25zIHByb3Blcmx5LlxuICovXG5mdW5jdGlvbiBnZXRTdWdnZXN0aW9ucyh3b3JkKXtcbiAgICBcbiAgICBpZihsYXN0V29yZFByb21pc2UpIHtcbiAgICAgICAgZ2V0V29yZHMod29yZCk7XG4gICAgICAgIHJldHVybiBsYXN0V29yZFByb21pc2U7XG4gICAgfVxuXG4gICAgZGVmZXIgPSBuZXcgJC5EZWZlcnJlZCgpO1xuICAgIGxhc3RXb3JkUHJvbWlzZSA9IGRlZmVyLnByb21pc2UoKTtcbiAgICBsYXN0V29yZCA9IHdvcmQ7XG5cbiAgICBmdW5jdGlvbiBnZXRXb3Jkcyh3cmQpe1xuICAgICAgICB3b3JkU3VnZ2VzdGlvbnMod3JkKS5kb25lKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgICBpZihyZXMgJiYgcmVzLndvcmQgPT0gbGFzdFdvcmQpe1xuICAgICAgICAgICAgICAgIGRlZmVyLnJlc29sdmUocmVzLm1hdGNoZXMpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3RXb3JkUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICBsYXN0V29yZCA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldFdvcmRzKCk7XG4gICAgcmV0dXJuIGxhc3RXb3JkUHJvbWlzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGdldFN1Z2dlc3Rpb25zXG59IiwiLyoqXG4gKiBJbml0aWFsaXplclxuICovXG5cbmltcG9ydCBkZWJvdW5jZSBmcm9tICcuL3V0aWwuanMnXG5pbXBvcnQgQXV0b2NvbXBsZXRlIGZyb20gJy4vYXV0b2NvbXBsZXRlLmpzJ1xuaW1wb3J0IGdldFN1Z2dlc3Rpb25zIGZyb20gJy4vU3VnZ2VzdGlvbi5qcydcblxud2luZG93Lm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGF1dG9Db21wbGV0ZSA9IG5ldyBBdXRvY29tcGxldGUoJyNzZWFyY2hCb3gnLCB7XG4gICAgICAgIHNlbGVjdDogYXV0b0NvbXBsZXRTZWxlY3RvclxuICAgIH0pO1xuXG4gICAgLy8gZGVib3VuY2UgaXQgZm9yIDEwMG1zXG4gICAgJCgnI3NlYXJjaEJveCcpLm9uKCdrZXl1cCcsIGRlYm91bmNlKGZ1bmN0aW9uKGV2ZW50LCB1aSl7XG5cbiAgICAgICAgdmFyIHNlbFN0YXJ0ID0gZXZlbnQudGFyZ2V0LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICB2YXIgc2VsRW5kID0gZXZlbnQudGFyZ2V0LnNlbGVjdGlvbkVuZDtcbiAgICAgICAgdmFyIHZhbHVlID0gJCh0aGlzKS52YWwoKVxuICAgICAgICB2YXIgd29yZFRvR2V0U3VnZ2VzdGlvbjtcbiAgICAgICAgaWYgKHNlbFN0YXJ0ID09IHNlbEVuZCAmJiBzZWxFbmQgPT0gdmFsdWUubGVuZ3RoKXtcbiAgICAgICAgICAgIC8vY3Vyc29yIGlzIGF0IHRoZSBsYXN0IHBvc2l0aW9uXG4gICAgICAgICAgICAvL2dldCB0aGUgbGFzdCB3b3JkLlxuICAgICAgICAgICAgd29yZFRvR2V0U3VnZ2VzdGlvbiA9IHZhbHVlLnNwbGl0KCcgJykucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL2lmIHNlbGVjdGlvbiBoYXMgbXVsdGlwbGUgd29yZHMsIHRoZW4gd2UgZ2V0IHRoZVxuICAgICAgICAgICAgLy9maXJzdCB3b3JkXG4gICAgICAgICAgICB3b3JkVG9HZXRTdWdnZXN0aW9uID0gdmFsdWUuc3Vic3RyKHNlbFN0YXJ0KS5zcGxpdCgnICcpLnBvcCgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXRjaGVzID0gZ2V0U3VnZ2VzdGlvbnMod29yZFRvR2V0U3VnZ2VzdGlvbik7XG4gICAgICAgIGF1dG9Db21wbGV0ZS5yZW5kZXJJdGVtcyhtYXRjaGVzKVxuXG4gICAgfSwgMTAwKSk7XG5cbiAgICB2YXIgYXV0b0NvbXBsZXRTZWxlY3RvciA9IGZ1bmN0aW9uKGVsZSwgc2VsZWN0ZWRJdGVtKXtcbiAgICAgICAgdmFyIGV4aXN0aW5nVmFsdWUgPSBlbGUudmFsKCk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBleGlzdGluZ1ZhbHVlLnNwbGl0KCcgJyk7XG4gICAgICAgIHZhciBzZWxlY3RlZFZhbHVlID0gc2VsZWN0ZWRJdGVtO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBsYXN0IGN1cnNvciBwb3NpdGlvbiwgXG4gICAgICAgIHZhciBjdXJzb3JQb3NpdGlvbiA9IGVsZS5kYXRhKCdjdXJzb3InKTtcbiAgICAgICAgaWYoY3Vyc29yUG9zaXRpb24gPT0gZXhpc3RpbmdWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhbHVlcy5wb3AoKTtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHNlbGVjdGVkSXRlbSk7XG4gICAgICAgICAgICB0b19zZXQgPSB2YWx1ZXMuam9pbignICcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJlZm9yZSA9IGV4aXN0aW5nVmFsdWUuc3Vic3RyKDAsY3Vyc29yUG9zaXRpb24pLmxhc3RJbmRleE9mKCcgJyk7XG4gICAgICAgIHZhciBhZnRlciA9IGV4aXN0aW5nVmFsdWUuc3Vic3RyKGN1cnNvclBvc2l0aW9uKS5pbmRleE9mKCcgJyk7XG4gICAgICAgIGlmKGJlZm9yZSAhPSAtMSl7XG4gICAgICAgICAgICB0b19zZXQgPSBleGlzdGluZ1ZhbHVlLnN1YnN0cigwLCBiZWZvcmUpICsgJyAnXG4gICAgICAgIH1cbiAgICAgICAgdG9fc2V0ID0gc2VsZWN0ZWRJdGVtXG4gICAgICAgIGlmKGFmdGVyICE9IC0xKXtcbiAgICAgICAgICAgIHRvX3NldCA9IGV4aXN0aW5nVmFsdWUuc3Vic3RyKDAsIGFmdGVyKVxuICAgICAgICB9XG5cbiAgICAgICAgZWxlLnZhbHVlKHRvX3NldCk7XG4gICAgICAgIC8vIGFmdGVyIHNlbGVjdGluZyBpdCBjbG9zZSBpdC5cbiAgICAgICAgYXV0b0NvbXBsZXRlLmNsb3NlKCk7XG4gICAgfVxufVxuXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")}]);